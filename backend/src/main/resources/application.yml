server:
  port: 8081

spring:
  datasource: # app_messages라는 DB에 대한 연결을 datasource에서 얻을 수 있도록
    url: jdbc:mysql://localhost:3306/app_messages?useUnicode=true&characterEncoding=UTF-8
    username: root
    password: 1234
    driver-class-name: com.mysql.cj.jdbc.Driver

  # 스프링부트가 JPA의 인터페이스인 EntityManager를 현재 스레드에 등록하는 OpenEntityManagerInViewInterceptor를 생성한다. 하지만
  # 리포지토리에서 하이버네이트의 SessionFactory를 사용하기 때문에, 트랜잭션 어드바이스에서 EntityManager를 SessionFactory로 캐스팅을 시도
  # 이것을 해결하기 위해서는, SessionFactory 대신 EntityManager를 사용하거나, 아래와 같이 이 기능을 해제한다.
  jpa:
    open-in-view: false

# slf4j 로그 레벨 설정
logging:
  level:
    app:
      messages:
        SecurityChecker: DEBUG # 디버그 레벨 로그 활성화
        MessageService: DEBUG
# MYSQL을 도커로 실행 ----------

# MYSQL 데이터 볼륨 컨테이너 생성 (아래 내용의 Dockerfile로 볼륨 컨테이너 생성)
# FROM busybox
# VOLUME /var/lib/mysql
# CMD ["bin/true"]
# 이 도커 파일을 통해, docker image build -t mysql-data:latest . 와 같이 이미지를 빌드
# docker container run -d --name mysql-data mysql-data:latest 그리고 나서 백그라운드로 실행
# 하지만 CMD 인스트럭션에서 셸을 실행하는 것이 전부기 때문에, 금방 실행이 종료된다.

# MYSQL 실행
# 그러고나서 볼륨 컨테이너 mysql-data를 MYSQL 컨테이너에 마운트하여 , MYSQL 컨테이너 실행
# docker container run -d --rm -p 3306:3306 --name mysql --volumes-from mysql-data mysql:5.7

# docker container run -d -p 3306:3306 --name mysql -e "MYSQL_ALLOW_EMPTY_PASSWORD=yes" \
# -e "MYSQL_DATABASE=test_db" -e "MYSQL_USER=user" -e "MYSQL_PASSWORD=1234" \
# --volumes-from mysql-data mysql:5.7

# MYSQL 패스워드 변경
# docker container exec -it mysql mysqladmin -uroot -p   password "1234"  # 공백을 1234로 바꾼다

# MYSQL 접속
# docker container exec -it mysql mysql -u root -p / password 입력

# MYSQL 테이블 생성
# CREATE TABLE messages (
#   id int(11) NOT NULL AUTO_INCREMENT,
#   text varchar(128) COLLATE utf8_bin NOT NULL DEFAULT '',
#   created_date datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
#   PRIMARY KEY (id)
# ) ENGINE=INNODB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

# curl을 통한 클라이언트 요청
# curl -X POST -d '{"text":"Hello, Spring Boot"}' -H "Content-Type: application/json" http://localhost:8081/messages | jq
