애자일 방식의 요구사항 분석

비즈니스 요구사항 / 조직목표 : 조직의 상위 수준의 비즈니스 목표. 조직이 시스템을 구축하는 이유.
사용자 요구사항 / 사용자 경험 : 사용자가 시스템으로 수행할 수 있는 작업 (사용자 스토리로 작성)
기능 요구사항 / 기능 구현 : 사용자 요구 사항에 정의된 작업을 수행하는 방법에 대한 시스템 동작을 명시

애자일 프로젝트에서는 개발자가 고객과 더 긴밀하게 상호작용을 하지만, 비즈니스 요구사항 문서는 여전히 필수 요소이다. 
사용자 요구 사항은 애자일 팀의 제품 백로그에 사용자 스토리로 작성 (그 기능을 구현하는데 있어 정확하게 안내할 수 있는 최소한의 문서를 만들것을 권장)
단위 테스트와 자동화 테스트에 기능 요구사항의 세부 정보를 유지하여, 요구사항 변경시 항상 테스트 코드를 최신으로 유지

사용자 요구사항 (사용자 스토리) 작성 예 : 
1. <사용자 유형>으로서, 나는 <어떤 가치 얻기>를 할 수 있도록, <어떤 것을 하기>를 원한다. (등록된 사용자로서, 로그인할 수 있도록, 사용자 이름과 비밀번호를 활용)
2. 작고 실행 가능하게 유지한다.
3. 허용 기준을 추가한다. (예 : 사용자 이름이 시스템에 이미 존재하면 안된다.)
4. 사용자 스토리를 그룹화하기 위해 테마를 사용한다. 각 테마별로 분류한다. (예 : 사용자, 팀, 보드, 카드 리스트, 카드)

데이터 모델링
개념적 모델링 - 애플리케이션의 요구사항을 데이터 요구사항으로 수렴 (각 테마 간 추가, 수행, 포함, 보유, 책임 등의 의존 관계를 ER 다이어그램으로 작성 (크로즈풋 표기법))
논리적 모델링 - 각각의 테마의 속성, 기본키, 외래키, 의존 관계를 정의한 엔티티 설계 / 테이블 간 관계를 가지는 엔티티 설계 
물리적 모델링 - 엔티티에 대응하는 테이블 생성, 속성에 대응하는 컬럼 생성 (유형, 길이, null 여부, 기본 값), 기본키를 자동증가로 설정, 인덱스 생성  

SOLID 디자인 원칙
- SRP : 단일 책임 원칙 - 한 클래스는 변경에 대한 이유를 하나만 가져야한다 (단일 주제를 가져야한다) / 하나의 메서드는 하나의 기능만을 수행해야한다
- OCP : 개방-폐쇄 원칙 - 수정 없이 확장할 수 있어야한다 / 필요할 경우 수정을 막기 위해 함수를 리팩토링한다
- LSP : 리스코프 치환 원칙 - 서브타입은 그것의 기반 유형으로 치환 가능해야한다 / 예컨대 매개변수로 전달되는 슈퍼 클래스와 서브 클래스는 동일하게 동작해야한다.
- ISP : 인터페이스 분리 원칙 - 클라이언트는 사용하지 않는 메서드에 의존하도록 강제되어서는 안된다 / 클래스는 꼭 필요한 기능만 가지는 최소로 작은 인터페이스만 구현해야한다.
- DIP : 의존 관계 역전 원칙 - (상위-비즈니스규칙, 하위-구현체 세부사항) 모듈은 상위 수준의 추상화에 의존해야한다 / 추상화는 구체적 사항에 의존하면 안된다.
구체적인 사항이 추상화에 의존하여야한다 / 클래스가 클래스를 직접 의존하기보다, 클래스가 인터페이스에 의존한다. 
- 파사드 디자인 패턴 : 비행 클래스는 비행에 관련된 메서드만 정의한 인터페이스를 구현하는 파사드 (통합된 인터페이스 / 서브시스템의 진입점) 와만 소통한다.
서브시스템 내부 세부사항을 알 필요가 없다 / 파사드는 비행 서브 시스템 내부에서 다른 클래스로 호출을 위임한다 / 클라이언트는 불필요한 메서드에 의존하지 않고,ISP 원칙 위반 X

-------------------------------------------------------------------------------------------------------

애자일 방법론의 네가지 가치 
- 공정과 도구보다 개인과 상호작용 
- 포괄적 문서보다 작동하는 소프트웨어
- 계약 협상보다 고객과의 협력
- 계획을 따르기보다 변화에 대응

풀스택 개발자의 기본
요구사항 분석, 와이어프레임 (간단한 UI) 작성, 데이터 모델링, API 설계
프론트, 백엔드, 단위테스트 및 자동화테스트, 지속적 통합 또는 지속적 전달, 서버 모니터링 및 아키텍처 이해 

애자일 코드 설계
- 아키텍처 단계 (아키텍처 설계)
- 추상화 단계 (서브 시스템을 구현할 때 서브 시스템 또는 모듈에 대한 추상화 단계의 설계 / 세부사항을 피하고 상위 수준의 정보만 제공)
- 구현 단계 (TDD, 현재의 사용자 요구사항에 집중, SOLID 디자인 원칙 등)

아키텍처 설계 (두가지 형태의 설계 방식)
- 계층형 아키텍처 : 복잡한 시스템을 별도의 계층으로 나눈다 / 각 계층은 관심사로 분리 / 일반적으로 프레젠테이션, 비즈니스, 데이터 접근 계층으로 나눈다.
도메인 로직을 보통 비즈니스 계층의 서비스 객체에 넣는다. 이런 도메인 모델을 빈약한 도메인 모델이라고 한다 / 복잡성이 커지면서, 도메인 로직이 다른 계층으로 누출될 수 있다.
계층형 아키텍처는 개발자가 도메인 모델 관점이 아닌, 데이터 관점에서 시스템을 바라보게 한다.
- 헥사고날 아키텍처 (육각형 아키텍처) : 도메인 주도 설계에 적합하다 / 중심에는 풍부한 도메인 모델이 있고, DB, 검색 엔진, 메시지 큐와 같은 인프라에서 도메인 로직을 분리한다.
다양한 유형의 클라이언트를 쉽게 지원하도록 확장할 수 있다. 거기에 새 어댑터를 추가하기만 하면 된다. 


